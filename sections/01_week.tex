\tableofcontents
\pagebreak

\section{Introduction}
\subsection{Why C++?}
\begin{itemize}
  \itemsep -0.5em 
  \item Work al almost all platforms from a micro controller to the main frame
  \item Multi-paradigm language with zero-cost abstraction
  \item High-level abstraction facilities
  \item The concepts from C++ can mostly be applied to any other programming language
\end{itemize}

\subsection{Features}
\begin{itemize}
  \itemsep -0.5em 
  \item C++ doesnt't has no methods only functions. A function does not have to be a member of an object. If a function belongs to an object it's a member function.
  \item Please do not write your own loops in C++ try to use the STL (Standard Template Library).
  \item C++ is compatible with standard C.
  \item There is no Garbage Collector!
  \item With a library we can publish functionalities to another program.
\end{itemize}

\subsection{Terminology}
\begin{minipage}{0,5\linewidth}
	\begin{description}
		\item[Value] 42
  		\item[Type] int, char, bool, long, float
  		\item[Variable] int const i\{42\}
  		\item[Expression] (2+4)*3
	\end{description}  
\end{minipage}
\begin{minipage}{0,5\linewidth}
	\begin{description}
   		\item[Statement] while ( true );
  		\item[Declaration] int foo();
  		\item [Definition] int j;
  		\item [Function] void bar ( ) \{ \}
	\end{description}  
\end{minipage}

\subsection{Undefined Behaviour}
The undefined behaviour is defined in the C++ standard (funny, isn't it?). Because of the fact, that C++ doesn't have a garbage collection, if in C++ something is written wrong and the compiler doesn't detect it: undefined behaviour can occur.

\subsection{C++ Compilation Process}
C++ has the advantage of direct compilation into machine code. This eliminates the overhead for a virtual machine in comparison to Java.

\textbf{*.cpp files for source code}
\begin{itemize}
  \itemsep -0.5em 
  \item Also called "Implementation File"
  \item Function implementations (can be in .h files as well)
  \item Source of compilation - aka "Translation Unit"
\end{itemize}
\textbf{*.h files for interfaces and templates}
\begin{itemize}
  \itemsep -0.5em 
  \item Called "Header File"
  \item Declarations and definitions to be used in other implementation files.
  \item Textual inclusion through a pre-processor (C++20 will incorporate a "Module" mechanism)
  \item \lstinline[language=C++]{#include "header.h"}
\end{itemize}

\textbf{3 Phases of Compilation}
\begin{itemize}
  \itemsep -0.5em 
  \item \textbf{Preprocessor} – Textual replacement of preprocessor directives, results in (*.i) files. (\lstinline[language=C++]{#include)}
  \item \textbf{Compiler} – Translation of C++ code into machine code (source file (*.i) to object file (*.o))
  \item \textbf{Linker} - Combination of object files (*.o) and libraries into libraries and executables (*.exe).
\end{itemize}

\subsection{Declarations and Definitions}
\textit{All things with a name that you use in a C++ program must be declared before you can do so!}

\textbf{Defining Functions}
\begin{center}
$<return-type> <function-name> (<parameters>) \{ /* body */ \}$
\end{center}
 Tells the compiler that there is a function named $<function-name>$ that takes the parameters $<parameters>$ and returns a value of type $<return-type>$. The Signature of a function is just the combination of name and the parameter types. 
 
\textbf{One Definition Rule}\\ 
 While a program element can be declared several times without problem there can be only one definition of it. \textbf{(ODR = One Definition Rule)}
 
\textbf{Include Guard}\\
Include guards ensure that a header file is only included once. Multiple inclusions could violate the One Definition Rule when the header contains definitions.
\begin{lstlisting}[language=c++]
#ifndef SAYHELLO_H_
#define SAYHELLO_H_
#include <iosfwd>
struct Greeter {
};
#endif /* SAYHELLO_H_ */ 
\end{lstlisting}