\section{Introduction}
\subsection{Why C++?}
\begin{itemize}
  \itemsep0em 
  \item Work al almost all platforms from a micro controller to the main frame
  \item Multi-paradigm language with zero-cost abstraction
  \item High-level abstraction facilities
  \item The concepts from C++ can mostly be applied to any other programming language
\end{itemize}

\subsection{Undefined Behaviour}
The undefined behaviour is defined in the C++ standard (funny, isn't it?). C++ has no garbage collector. If in C++ something is written wrong and the compiler doesn't detect it: undefined behaviour can occur.

\subsection{C++ Compilation Process}
\textbf{*.cpp files for source code}
\begin{itemize}
  \itemsep -0.5em 
  \item Also called "Implementation File"
  \item Function implementations (can be in .h files as well)
  \item Source of compilation - aka "Translation Unit"
\end{itemize}
\textbf{*.h files for interfaces and templates}
\begin{itemize}
  \itemsep -0.5em 
  \item Called "Header File"
  \item Declarations and definitions to be used in other implementation files.
  \item Textual inclusion through a pre-processor (C++20 will incorporate a "Module" mechanism)
  \item \#include "header.h"
\end{itemize}

\textbf{3 Phases of Compilation}
\begin{itemize}
  \itemsep -0.5em 
  \item \textbf{Preprocessor} – Textual replacement of preprocessor directives (\#include)
  \item \textbf{Compiler} – Translation of C++ code into machine code (source file to object file)
  \item \textbf{Linker} - Combination of object files and libraries into libraries and executables
\end{itemize}

\subsection{Declarations and Definitions}
\textit{All things with a name that you use in a C++ program must be declared before you can do so!}

\textbf{Defining Functions}
\begin{center}
$<return-type> <function-name> (<parameters>) \{ /* body */ \}$
\end{center}
 Tells the compiler that there is a function named $<function-name>$ that takes the parameters $<parameters>$ and returns a value of type $<return-type>$. The Signature of a function is just the combination of name and the parameter types. 
 
\textbf{One Definition Rule}\\ 
 While a program element can be declared several times without problem there can be only one definition of it. \textbf{(ODR = One Definition Rule)}
 
\textbf{Include Guard}\\
Include guards ensure that a header file is only included once. Multiple inclusions could violate the One Definition Rule when the header contains definitions.
\begin{lstlisting}[language=c++]
#ifndef SAYHELLO_H_
#define SAYHELLO_H_
#include <iosfwd>
struct Greeter {
};
#endif /* SAYHELLO_H_ */ 
\end{lstlisting}


