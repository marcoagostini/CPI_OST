%You know when and why to prefer standard algorithms over hand-written loops 
%You can name the most important algorithms in the STL 
%You can explain certain pittfalls when using STL algorithms 
%You can explain the signature of a standard algorithm 
%You can write programs that correctly use standard algorithms


\section{Class Templates}

\begin{itemize}
  \itemsep 0em 
  \item In addition to functions also class types can habe template parameters
  \item Since C++17, similar to function templates, the compiler might deduce the template arguments
  \item Compile-time polymorphism
  \item Class templates can be specialized
\end{itemize}

\textbf{Rules} \\
\begin{itemize}
  \itemsep 0em 
  \item Define class templates completely in header files
  \item Member functions of class templates
  	\SubItem{Either in class template directly}
  	\SubItem{Or as inline function templates in the same header file}
  \item When using language elements depending directly or indirectly on a template parameter, you must specify typename when it is naming a type.
  \item static member variables of a template class can be defined in header without violating ODR, even if included in several compilation units.
 
\end{itemize}


\begin{minipage}{0,5\linewidth}
  \begin{lstlisting}[language=C++]
  std::vector<int> oldValues{1, 2, 3};
  \end{lstlisting}
\end{minipage}
\begin{minipage}{0,5\linewidth}
  \begin{lstlisting}[language=C++]
  std::vector newValues{1, 2, 3};
  std::vector<int> emptyValues{};
  \end{lstlisting}
\end{minipage}

\begin{lstlisting}
template <TemplateParameters>
class TemplateName { /*...*/ };

template <typename T>
class Stack { /*...*/ };
\end{lstlisting}

Example
\begin{lstlisting}[language=C++]
template <typename T>
class Sack {
	using SackType = std::vector<T>;
	using size_type = typename SackType::size_type;
	SackType theSack{};
	
public:
	bool empty() const {
		return theSack.empty();
	}
	size_type size() const {
		return theSack.size();
	}
	void putInto(T const & item) {
		theSack.push_back(item);
	}
	T getOut();
};
\end{lstlisting}
Deffinieren einer FUnktion ausserhalb der Klassendefinition
\begin{lstlisting}[language=C++]
template <typename T> 
inline T Sack<T>::getOut() {
	if (empty()) {
		throw std::logic_error{"Empty Sack"}; 
	} 
	auto index = static_cast<size_type>(rand() % size()); 
	T retval{theSack.at(index)};
	theSack.erase(theSack.begin() + index);
	return retval;
}
\end{lstlisting}

\subsection{Type Aliases (C++11)}
It is common for template definitions to define type aliases in order to ease their use. This has the advantage of less typing and reading als also a single point to change the aliased type. Before used typedef.

\begin{lstlisting}
using StackType = std::vector<T>;
\end{lstlisting}

%TODO dependent names
%TODO Inheritance





\pagebreak
